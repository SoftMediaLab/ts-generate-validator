/* This file was automatically generated and should not be edited */
// tslint:disable
/* eslint-disable */

{% for import in imports %}
import { {{ import.clauses }} } from '{{ import.path }}';
{% endfor %}

{% for validation in validations %}
export const {{ validation.name }}: GeneratedValidation = {% if validation.async %}async {% endif %}<
  D extends Data = typeof {{ validation.modelClassName }},
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];

  try {
    {% for item in validation.items %}
    {% if item.async %}await {% endif %}{{ item.validatorName }}({
      property: data?.{{ item.propertyName }},
      propertyName: `${propNamePrefix}{{ item.propertyName }}`,
      data,
      {% if item.optional !== undefined %}optional: {{ item.optional }},{% endif %}
      config,
      context,
      {% for vArg in item.validatorPayload %}
      {{ vArg.property }}: {% if vArg.type === 'string' %}'{{ vArg.value }}'{% else %}{{ vArg.value | validatorPayloadValueFilter(vArg.property) }}{% endif %},
      {% endfor %}
    });
    {% endfor %}
  } catch (err) {
    if (!(err instanceof ValidationError)) {
      throw err;
    }
    
    errors.push(err);

    if (config.stopAtFirstError) {
      throw new ValidationException(errors);
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
}

{% endfor %}